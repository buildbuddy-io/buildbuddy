"use strict";(self.webpackChunkbuildbuddy_docs_website=self.webpackChunkbuildbuddy_docs_website||[]).push([[1102],{52279:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"remote-runner-introduction","title":"Introduction to Remote Runners","description":"A BuildBuddy remote runner is an execution environment that runs on a BuildBuddy executor.","source":"@site/../docs/remote-runner-introduction.md","sourceDirName":".","slug":"/remote-runner-introduction","permalink":"/docs/remote-runner-introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/buildbuddy-io/buildbuddy/edit/master/docs/../docs/remote-runner-introduction.md","tags":[],"version":"current","lastUpdatedBy":"Siggi Simonarson","lastUpdatedAt":1763590905000,"frontMatter":{"id":"remote-runner-introduction","title":"Introduction to Remote Runners","sidebar_label":"Remote Runner Introduction"},"sidebar":"someSidebar","previous":{"title":"RBE Executor Pools","permalink":"/docs/rbe-pools"},"next":{"title":"Remote Runner Features","permalink":"/docs/remote-runner-features"}}');var o=s(74848),a=s(28453);const t={id:"remote-runner-introduction",title:"Introduction to Remote Runners",sidebar_label:"Remote Runner Introduction"},i=void 0,l={},c=[{value:"Differences between Workflows and Remote Bazel",id:"differences-between-workflows-and-remote-bazel",level:2},{value:"Workflows",id:"workflows",level:4},{value:"Remote Bazel",id:"remote-bazel",level:4},{value:"Benefits of remote runners",id:"benefits-of-remote-runners",level:2},{value:"Colocation with BuildBuddy servers",id:"colocation-with-buildbuddy-servers",level:3},{value:"Hosted, warm, Bazel instances",id:"hosted-warm-bazel-instances",level:3},{value:"Runner recycling",id:"runner-recycling",level:2},{value:"Firecracker VMs (Linux only)",id:"firecracker-vms-linux-only",level:3},{value:"Recommended configuration",id:"recommended-configuration",level:4},{value:"Snapshot save policy",id:"snapshot-save-policy",level:4},{value:"Overriding the snapshot save policy",id:"overriding-the-snapshot-save-policy",level:5},{value:"Snapshot read policy",id:"snapshot-read-policy",level:4},{value:"Runner recycling (macOS only)",id:"runner-recycling-macos-only",level:3},{value:"Optimal usage of remote runners",id:"optimal-usage-of-remote-runners",level:2},{value:"Getting started",id:"getting-started",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"A BuildBuddy remote runner is an execution environment that runs on a BuildBuddy executor.\nOur remote runners are optimized to run Bazel commands, and allow users to maintain\na warm bazel instance in a secure execution environment managed by BuildBuddy.\nFor example, this might look like a Firecracker microVM or an OCI container where\nyou can run Bazel commands."}),"\n",(0,o.jsx)(n.p,{children:"BuildBuddy remote runners have the following unique advantages:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Colocation with BuildBuddy servers, ensuring a ",(0,o.jsx)(n.strong,{children:"fast network\nconnection"})," between Bazel and BuildBuddy's cache & RBE servers."]}),"\n",(0,o.jsxs)(n.li,{children:["Running workloads in ",(0,o.jsx)(n.strong,{children:"persistent execution environments"})," using microVM\nsnapshotting (on Linux) and persistent runners (on macOS). This allows reusing\nBazel's in-memory analysis cache and local disk cache, achieving higher performance\ncompared to remote caching alone."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"There are two ways to use remote runners:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"BuildBuddy Workflows:"})," Our continuous integration (CI) solution that runs Bazel builds and tests in response to git events (pull requests or pushes)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Remote Bazel:"})," a CLI tool that works exactly like the Bazel command, but runs Bazel on a remote workspace and streams the output back to the local machine."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"https://www.buildbuddy.io/blog/meet-buildbuddy-workflows",children:"our blog post"}),"\nfor more details on the motivation behind remote runners as well as some\nreal-world results."]}),"\n",(0,o.jsx)(n.p,{children:"We currently support two products built on top of remote runners: Workflows and\nRemote Bazel."}),"\n",(0,o.jsx)(n.h2,{id:"differences-between-workflows-and-remote-bazel",children:"Differences between Workflows and Remote Bazel"}),"\n",(0,o.jsx)(n.p,{children:"In many ways, Remote Bazel and Workflows are the same product and share much of\nthe same backend code. Both are mechanisms to run code on remote runners. The\nprimary difference is the entrypoint."}),"\n",(0,o.jsx)(n.h4,{id:"workflows",children:"Workflows"}),"\n",(0,o.jsx)(n.p,{children:"Workflows are configured with a config YAML that is checked in to GitHub.\nRemote runs can be automatically triggered by GitHub events, like push and\npull events. Workflows are commonly used as a Continuous Integration (CI) solution."}),"\n",(0,o.jsx)(n.p,{children:"Workflows are a good fit if you:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Have a static list of commands to run"}),"\n",(0,o.jsx)(n.li,{children:"Want your commands checked in to your codebase for review"}),"\n",(0,o.jsx)(n.li,{children:"Are exclusively using BuildBuddy to run CI and do not have another CI provider\nthat can initiate commands"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"remote-bazel",children:"Remote Bazel"}),"\n",(0,o.jsx)(n.p,{children:"Remote Bazel can be configured by CURL request or by using the BuildBuddy CLI.\nRemote Bazel can be used as a Continuous Integration (CI) solution, or by developers\nin their daily workflows for use cases that are more dynamic than CI."}),"\n",(0,o.jsx)(n.p,{children:"Remote Bazel is a good fit if you:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Have a dynamic or frequently changing list of commands to run, that you do not\nwant to check into your codebase"}),"\n",(0,o.jsx)(n.li,{children:"You are continuing to use a legacy CI platform and want to integrate BuildBuddy\ninto it"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"benefits-of-remote-runners",children:"Benefits of remote runners"}),"\n",(0,o.jsx)(n.h3,{id:"colocation-with-buildbuddy-servers",children:"Colocation with BuildBuddy servers"}),"\n",(0,o.jsx)(n.p,{children:"Network latency is often the biggest bottleneck in many Bazel Remote Build\nExecution and Remote Caching setups. This is because Bazel's remote APIs\nrequire several chained RPCs due to dependencies between actions."}),"\n",(0,o.jsx)(n.p,{children:"To address this bottleneck, BuildBuddy remote runners are executed in the same\ndatacenters where BuildBuddy RBE and Cache nodes are deployed. This\nresults in sub-millisecond round trip times to BuildBuddy's servers,\nminimizing the overhead incurred by Bazel's remote APIs."}),"\n",(0,o.jsx)(n.h3,{id:"hosted-warm-bazel-instances",children:"Hosted, warm, Bazel instances"}),"\n",(0,o.jsx)(n.p,{children:"Running Bazel on most CI solutions is typically expensive and slow.\nThere are several sources of overhead:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"When using Bazelisk, Bazel itself is re-downloaded and extracted on each\nCI run."}),"\n",(0,o.jsx)(n.li,{children:"The Bazel server starts from a cold JVM, meaning that it will be running\nunoptimized code until the JIT compiler kicks in."}),"\n",(0,o.jsx)(n.li,{children:"Bazel's analysis cache starts empty, which often means the entire\nworkspace has to be re-scanned on each CI run."}),"\n",(0,o.jsx)(n.li,{children:"Any remote repositories referenced by the Bazel workspace all have to be\nre-fetched on each run."}),"\n",(0,o.jsx)(n.li,{children:"Bazel's on-disk cache starts completely empty, causing action\nre-execution or excess remote cache usage."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A common solution is to use something like\n",(0,o.jsx)(n.a,{href:"https://github.com/actions/cache",children:"actions/cache"})," to store Bazel's cache\nfor reuse between runs, but this solution is extremely data-intensive, as\nBazel's cache can be several GB in size and consist of many individual\nfiles which are expensive to unpack from an archive. It also does not\nsolve the problems associated with the Bazel server having starting from\nscratch."]}),"\n",(0,o.jsxs)(n.p,{children:["By contrast, BuildBuddy uses a Bazel workspace reuse approach, similar to\nhow ",(0,o.jsx)(n.a,{href:"https://dl.acm.org/doi/pdf/10.1145/3395363.3397371",children:"Google's Build Dequeuing Service"})," performs\nworkspace selection:"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"A well-chosen workspace can increase the build speed by an\norder of magnitude by reusing the various cached results from the\nprevious execution. [...] We have observed that builds that execute the same targets as a previous\nbuild are effectively no-ops using this technique"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"runner-recycling",children:"Runner recycling"}),"\n",(0,o.jsxs)(n.p,{children:["To match workloads to warm runners, BuildBuddy uses VM\nsnapshotting powered by\n",(0,o.jsx)(n.a,{href:"https://github.com/firecracker-microvm/firecracker",children:"Firecracker"})," on\nLinux, and a simpler runner-recycling based approach on macOS."]}),"\n",(0,o.jsx)(n.h3,{id:"firecracker-vms-linux-only",children:"Firecracker VMs (Linux only)"}),"\n",(0,o.jsx)(n.p,{children:"On Linux, remote runs are executed inside Firecracker VMs, which\nhave a low startup time (hundreds of milliseconds). VM snapshots include\nthe full disk and memory contents of the machine, meaning that the Bazel\nserver is effectively kept warm between runs."}),"\n",(0,o.jsx)(n.p,{children:"Remote runners use a sophisticated snapshotting mechanism that minimizes the\nwork that Bazel has to do on each CI run."}),"\n",(0,o.jsx)(n.p,{children:"First, VM snapshots can be stored both locally on the machine that ran the\nremote run, as well as remotely in BuildBuddy's cache. This way, if the\noriginal machine that ran the remote run is fully occupied with other\nworkloads, subsequent runs can be executed on another machine,\nbut still be able to resume from a warm VM snapshot. BuildBuddy stores VM\nsnapshots in granular chunks that are downloaded lazily, so that unneeded\ndisk and memory chunks are not re-downloaded."}),"\n",(0,o.jsx)(n.p,{children:"Second, snapshots are stored using a branching model that closely mirrors\nthe branching structure of the git repository itself, allowing remote runs\nto be matched optimally to VM snapshots."}),"\n",(0,o.jsx)(n.p,{children:"After a remote run executes on a particular git branch, BuildBuddy snapshots the\nVM and saves it under a cache key which includes the git branch."}),"\n",(0,o.jsx)(n.p,{children:"When starting a remote run on a particular git branch, BuildBuddy\nattempts to locate an optimal snapshot to run it. It considers\nthe following snapshot keys in order:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"The latest snapshot matching the git branch associated with the\nrun."}),"\n",(0,o.jsx)(n.li,{children:"The latest snapshot matching the base branch of the PR associated with\nthe run."}),"\n",(0,o.jsx)(n.li,{children:"The latest snapshot matching the default branch of the repo associated\nwith the run."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For example, consider a remote run that runs on pull requests\n(PRs). Given a PR that is attempting to merge the branch ",(0,o.jsx)(n.code,{children:"users-ui"})," into a\nPR base branch ",(0,o.jsx)(n.code,{children:"users-api"}),", BuildBuddy will first try to resume the latest\nsnapshot associated with the ",(0,o.jsx)(n.code,{children:"users-ui"})," branch. If that doesn't exist,\nwe'll try to resume from the snapshot associated with the ",(0,o.jsx)(n.code,{children:"users-api"}),"\nbranch. If that doesn't exist, we'll look for a snapshot for the ",(0,o.jsx)(n.code,{children:"main"}),"\nbranch (the repo's default branch). If all of that fails, only then do we\nboot a new VM from scratch. When the remote run finishes and we save a\nsnapshot, we only overwrite the snapshot for the ",(0,o.jsx)(n.code,{children:"users-ui"})," branch,\nmeaning that the ",(0,o.jsx)(n.code,{children:"users-api"})," and ",(0,o.jsx)(n.code,{children:"main"})," branch snapshots will not be\naffected."]}),"\n",(0,o.jsx)(n.p,{children:"One common issue is not running any remote runs on your default branch.\nEvery time there is a new PR branch, for example, the remote run will start from\nscratch because there is not a shared default snapshot for them to start from. One\nsolution is to trigger a remote run on every push to the default branch, to make sure\nthe default snapshot stays up to date."}),"\n",(0,o.jsxs)(n.p,{children:["For more technical details on our VM implementation, see our BazelCon\ntalk ",(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=YycEXBlv7ZA",children:"Reusing Bazel's Analysis Cache by Cloning Micro-VMs"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"recommended-configuration",children:"Recommended configuration"}),"\n",(0,o.jsxs)(n.p,{children:["Snapshot matching is complex and different strategies come with performance\nor cost trade-offs. More details can be found below at ",(0,o.jsx)(n.a,{href:"#snapshot-save-policy",children:"Snapshot save policy"}),"\nand ",(0,o.jsx)(n.a,{href:"#snapshot-read-policy",children:"Snapshot read policy"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Here are the recommended platform properties for most CI use cases. They balance\ncost considerations and maintain good performance:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"remote-snapshot-save-policy=none-available"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"snapshot-read-policy=local-first"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"max-stale-fallback-snapshot-age=1d"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For performance-sensitive or interactive workloads (like if you're using the Remote\nBazel CLI to build interactively), we recommend the following platform properties.\nThey will result in higher cache upload and download and associated costs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"remote-snapshot-save-policy=always"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"snapshot-read-policy=newest"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For Workflows, you can set platform properties using the ",(0,o.jsx)(n.code,{children:"platform_properties"})," field."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="buildbuddy.yaml"',children:'actions:\n  - name: "Test all targets"\n    platform_properties:\n      remote-snapshot-save-policy: none-available\n    env:\n      GIT_REPO_DEFAULT_BRANCH: main\n    # ...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For Remote Bazel, you can set platform properties this using the\n",(0,o.jsx)(n.code,{children:"--runner_exec_properties=remote-snapshot-save-policy="})," flag."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",metastring:"Sample Command",children:"bb remote --runner_exec_properties=remote-snapshot-save-policy=none-available test //...\n"})}),"\n",(0,o.jsx)(n.p,{children:"NOTE: Setting platform properties will change the snapshot key. Immediately after\nyou update a platform property, you will see snapshot misses until a new default\nsnapshot with the new properties is saved."}),"\n",(0,o.jsx)(n.h4,{id:"snapshot-save-policy",children:"Snapshot save policy"}),"\n",(0,o.jsx)(n.p,{children:"In order to reuse a warm VM, a snapshot of the machine must be taken and cached. While\nthis ensures good performance for future runs, caching snapshots can be expensive."}),"\n",(0,o.jsx)(n.p,{children:"Snapshots can be very large because they include the entirety of\nthe disk and memory of the machine. For example, a VM with 16GB memory and a 50GB disk results in a 66GB\nsnapshot file. Storing them in the remote cache can cause significant network transfer, and\nbecause cache uploads and downloads are billed, caching lots of snapshots may result in a high bill."}),"\n",(0,o.jsxs)(n.p,{children:["We support configuring the snapshot save policy with the ",(0,o.jsx)(n.code,{children:"remote-snapshot-save-policy"}),"\nplatform property. See ",(0,o.jsx)(n.a,{href:"#recommended-configuration",children:"Recommended configuration"})," for our recommendations.\nValid values are:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"always"}),": Always save a snapshot.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"For performance sensitive or interactive workloads, this will ensure the latest snapshot is\nalways saved to the cache and will always be accessible."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"first-non-default-ref"}),": Only the first run on a non-default ref will save a snapshot.\nAll runs on default refs will save a snapshot.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"This policy is applied by default."}),"\n",(0,o.jsxs)(n.li,{children:["Every run on the default branch (Ex. ",(0,o.jsx)(n.code,{children:"main"})," or ",(0,o.jsx)(n.code,{children:"master"}),") will save a snapshot."]}),"\n",(0,o.jsxs)(n.li,{children:["The first run on your feature branch ",(0,o.jsx)(n.code,{children:"my-feature"})," can resume from the default\nsnapshot, and will save a snapshot for the ",(0,o.jsx)(n.code,{children:"my-feature"})," ref."]}),"\n",(0,o.jsxs)(n.li,{children:["The second run on the ",(0,o.jsx)(n.code,{children:"my-feature"})," branch will resume from the original ",(0,o.jsx)(n.code,{children:"my-feature"}),"\nsnapshot. However it will not save a snapshot."]}),"\n",(0,o.jsxs)(n.li,{children:["The third run on the ",(0,o.jsx)(n.code,{children:"my-feature"})," branch will resume from the original ",(0,o.jsx)(n.code,{children:"my-feature"}),"\nsnapshot. It will not resume from the second run of the ",(0,o.jsx)(n.code,{children:"my-feature"})," branch, and\nit will not save a snapshot."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"none-available"}),": A snapshot on a non-default ref will only be saved if\nthere are no snapshots available. If there is any fallback snapshot,\na snapshot will not be saved. All runs on default refs will still save a snapshot.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Every run on the default branch (Ex. ",(0,o.jsx)(n.code,{children:"main"})," or ",(0,o.jsx)(n.code,{children:"master"}),") will save a snapshot."]}),"\n",(0,o.jsxs)(n.li,{children:["For the first run on your feature branch ",(0,o.jsx)(n.code,{children:"my-feature"}),", if there is snapshot\nfor the default branch available, you will resume from it. Because you resumed\nfrom a snapshot, a snapshot will not be saved."]}),"\n",(0,o.jsxs)(n.li,{children:["Subsequent runs on the ",(0,o.jsx)(n.code,{children:"my-feature"})," branch will resume from the default snapshot,\nbecause no snapshots were saved for the ",(0,o.jsx)(n.code,{children:"my-feature"})," branch."]}),"\n",(0,o.jsxs)(n.li,{children:["If there is no default snapshot available, then a snapshot will be saved\nfor the ",(0,o.jsx)(n.code,{children:"my-feature"})," branch on its first run."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"#recommended-configuration",children:"Recommended configuration"})," for details on how to\napply these properties."]}),"\n",(0,o.jsxs)(n.p,{children:["NOTE: This property relies on the ",(0,o.jsx)(n.code,{children:"GIT_REPO_DEFAULT_BRANCH"})," environment variable\nto be set (it should be set to something like ",(0,o.jsx)(n.code,{children:"main"})," or ",(0,o.jsx)(n.code,{children:"master"})," depending on your\nrepo's default branch)."]}),"\n",(0,o.jsx)(n.p,{children:"If your workflow was triggered by a GitHub webhook event or the Remote Bazel CLI,\nthis environment variable will be set automatically. If you plan to manually\ndispatch a Workflow with the ExecuteWorkflow API or our UI, or a Remote Bazel\ncommand with the Run API, you must manually set this environment variable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="buildbuddy.yaml"',children:'actions:\n  - name: "Test all targets"\n    platform_properties:\n      remote-snapshot-save-policy: none-available\n    env:\n      GIT_REPO_DEFAULT_BRANCH: main\n    # ...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For Remote Bazel, you can configure this using the\n",(0,o.jsx)(n.code,{children:"--runner_exec_properties=remote-snapshot-save-policy="})," flag."]}),"\n",(0,o.jsxs)(n.p,{children:["NOTE: If your run is triggered by the BB CLI, the ",(0,o.jsx)(n.code,{children:"GIT_REPO_DEFAULT_BRANCH"}),"\nenvironment variable will be set automatically. We use this to determine whether\nthe Workflow is running on a default ref. If you plan to use the ",(0,o.jsx)(n.code,{children:"Run"})," API directly,\nyou must manually set this environment variable in the API request for this to work as\nexpected."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",metastring:"Sample Command",children:"bb remote --runner_exec_properties=remote-snapshot-save-policy=none-available test //...\n"})}),"\n",(0,o.jsx)(n.h5,{id:"overriding-the-snapshot-save-policy",children:"Overriding the snapshot save policy"}),"\n",(0,o.jsx)(n.p,{children:"If you want to override the snapshot save policy for a specific run, you\ncan use a remote header. For example, lets say you typically\nset a snapshot save policy where a snapshot would not be saved for a given workload, but you'd like to force a snapshot save for debug purposes."}),"\n",(0,o.jsx)(n.p,{children:"By default, platform properties are hashed in the\nsnapshot key, so changing the snapshot save policy would invalidate your snapshot.\nHowever platform properties set in remote headers are not included in the snapshot\nkey."}),"\n",(0,o.jsxs)(n.p,{children:["For example, lets say you use the ",(0,o.jsx)(n.code,{children:"first-non-default-ref"})," policy, but wish\nto force save a specific remote snapshot run to do some additional debugging. You\ncould apply that with a command like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",metastring:"Sample Command",children:"bb remote --remote_run_header=x-buildbuddy-platform.remote-snapshot-save-policy=always test //...\n"})}),"\n",(0,o.jsxs)(n.p,{children:['Workflows do not support setting remote headers, but you can use Remote Bazel to\nforce save a snapshot that is used by Workflows. From the invocation page for your\nWorkflow, on the Executions tab next to the label "Saved to snapshot ID", there\nis a button named ',(0,o.jsx)(n.code,{children:"Copy Remote Bazel command to run commands in snapshot"}),". You\ncan add ",(0,o.jsx)(n.code,{children:"--remote_run_header=x-buildbuddy-platform.remote-snapshot-save-policy=X"}),"\nto this command to force save a remote snapshot."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",metastring:"Sample Command",children:'bb remote --remote_run_header=x-buildbuddy-platform.remote-snapshot-save-policy=always --run_from_snapshot=\'{"snapshotId":"XXX","instanceName":""}\' --script=\'echo "Just running this to force save a remote snapshot."\'\n'})}),"\n",(0,o.jsx)(n.h4,{id:"snapshot-read-policy",children:"Snapshot read policy"}),"\n",(0,o.jsx)(n.p,{children:"VM snapshots can be stored both locally on the machine that ran the\nremote run, as well as remotely in BuildBuddy's cache."}),"\n",(0,o.jsx)(n.p,{children:"There are pros and cons to local vs remote snapshots."}),"\n",(0,o.jsx)(n.p,{children:"Resuming from a local snapshot is often faster, because the large snapshots don't have to be fetched over the network. They are also more economical, because remote cache reads are billed at a higher rate. Due to snapshots' size, reading remote snapshots can result in high cache download."}),"\n",(0,o.jsx)(n.p,{children:"However local snapshots may be inaccessible by future workloads if the original machine is fully occupied and can't accept additional\nwork, or if the executor is restarting during a release. Remote snapshots can be\nfetched from any machine, and guarantee you'll always be able to resume from a warm VM."}),"\n",(0,o.jsx)(n.p,{children:"When looking for a snapshot, we look in the following order:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Search for a local snapshot on the same branch of the current run."}),"\n",(0,o.jsx)(n.li,{children:"Search for a remote snapshot on the same branch."}),"\n",(0,o.jsxs)(n.li,{children:["Search for a local snapshot on a fallback branch (typically the default branch, like\n",(0,o.jsx)(n.code,{children:"main"})," or ",(0,o.jsx)(n.code,{children:"master"}),")."]}),"\n",(0,o.jsx)(n.li,{children:"Search for a remote snapshot on a fallback branch."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["We support configuring the snapshot read policy with the ",(0,o.jsx)(n.code,{children:"snapshot-read-policy"}),"\nplatform property. Valid values are:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"newest"}),": Always read the newest snapshot available.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"For performance-sensitve or interactive workloads, this will ensure the\nmost recently updated snapshot is used."}),"\n",(0,o.jsx)(n.li,{children:"This could be a local or remote snapshot."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"local-first"}),": Use a local snapshot if available.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"This is more economical, because remote cache reads are billed at a higher rate."}),"\n",(0,o.jsx)(n.li,{children:"This may mean that even if a newer remote snapshot exists, a more stale local\nsnapshot may be used."}),"\n",(0,o.jsxs)(n.li,{children:["This can be used in conjunction with the platform property ",(0,o.jsx)(n.code,{children:"max-stale-fallback-snapshot-age"}),",\nwhich is described in more detail below."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"local-only"}),": Only use local snapshots.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"This may result in more snapshot misses, and more runs will start from clean runners."}),"\n",(0,o.jsx)(n.li,{children:"Local snapshots may become unusable if the executor that has it cached locally\nis fully occupied with other workloads or is restarting during a release.\nWhereas remote snapshots are usable no matter the underlying executor."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Snapshot reads are also configurable with the ",(0,o.jsx)(n.code,{children:"max-stale-fallback-snapshot-age"}),"\nplatform property. Valid values are durations like ",(0,o.jsx)(n.code,{children:"12h"})," or ",(0,o.jsx)(n.code,{children:"1d"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"This platform sets a limit on the max age of a fallback snapshot to prevent using very stale local snapshots that may cause performance degradation. The system will then fetch a newer remote snapshot."}),"\n",(0,o.jsxs)(n.p,{children:["For example, let's say you set ",(0,o.jsx)(n.code,{children:"snapshot-read-policy=local-first"})," and\n",(0,o.jsx)(n.code,{children:"max-stale-fallback-snapshot-age=1d"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The first run on your feature branch ",(0,o.jsx)(n.code,{children:"my-feature"})," runs on Machine A and resumes from a fallback\nsnapshot on the default branch ",(0,o.jsx)(n.code,{children:"main"}),". There is no local snapshot for ",(0,o.jsx)(n.code,{children:"main"}),"\navailable, so it will fetch a remote snapshot. It will cache this ",(0,o.jsx)(n.code,{children:"main"})," snapshot\nlocally (",(0,o.jsx)(n.code,{children:"Main A"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["A ",(0,o.jsx)(n.code,{children:"main"})," workflow runs on another machine, and saves a newly updated ",(0,o.jsx)(n.code,{children:"main"}),"\nsnapshot to the remote cache (",(0,o.jsx)(n.code,{children:"Main B"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["20 minutes later, the first run of another feature branch ",(0,o.jsx)(n.code,{children:"feature-2"})," runs on Machine A and\nresumes from a fallback snapshot on ",(0,o.jsx)(n.code,{children:"main"}),". It will resume from the local snapshot\n",(0,o.jsx)(n.code,{children:"Main A"})," due to the snapshot read policy ",(0,o.jsx)(n.code,{children:"local-first"}),", even though a more recent\nsnapshot on ",(0,o.jsx)(n.code,{children:"main"})," exists in the remote cache (",(0,o.jsx)(n.code,{children:"Main B"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["1 day 20 minutes later, the first run of another feature branch ",(0,o.jsx)(n.code,{children:"feature-3"}),"\nruns on Machine A and resumes from a fallback snapshot on ",(0,o.jsx)(n.code,{children:"main"}),". This time,\nthe local snapshot ",(0,o.jsx)(n.code,{children:"Main A"})," is too stale, because the max fallback age was set to ",(0,o.jsx)(n.code,{children:"1d"}),".\nIt will fetch and resume from the remote snapshot ",(0,o.jsx)(n.code,{children:"Main B"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"runner-recycling-macos-only",children:"Runner recycling (macOS only)"}),"\n",(0,o.jsx)(n.p,{children:"On macOS, remote runs are matched to workspaces using a simpler\nrunner-recycling based approach. Remote runs are associated with Git\nrepositories, and matched to any runner associated with the repository.\nEach runner keeps a separate Bazel workspace directory and on-disk cache,\nas well as its own Bazel server instance, which is kept alive between\nruns. Runners are evicted from the machine only if the number of runners\nexceeds a configured limit or if the disk resource usage exceeds a\nconfigured amount."}),"\n",(0,o.jsxs)(n.p,{children:["macOS remote runners are only available for self-hosted Macs. See our\n",(0,o.jsx)(n.a,{href:"workflows-config#mac-configuration",children:"configuration docs"})," for more details,\nor ",(0,o.jsx)(n.a,{href:"https://www.buildbuddy.io/contact",children:"contact us"})," for more info about\nBuildBuddy-managed Macs."]}),"\n",(0,o.jsx)(n.h2,{id:"optimal-usage-of-remote-runners",children:"Optimal usage of remote runners"}),"\n",(0,o.jsx)(n.p,{children:"While our remote runners support running arbitrary bash code, they were specifically\ndesigned and optimized to run the Bazel client server and power Bazel commands with\nremote execution (RBE)."}),"\n",(0,o.jsx)(n.p,{children:"Because we snapshot the entire memory and disk of each runner, the product is slower\nwhen we must serialize and deserialize larger runners. Thus we have a 100GB limit\non disks for remote runners."}),"\n",(0,o.jsx)(n.p,{children:"It's more effective when a smaller remote runner is used to orchestrate farming out most computation to\ntraditional Bazel remote executors."}),"\n",(0,o.jsx)(n.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,o.jsxs)(n.p,{children:["You can get started with [BuildBuddy Workflows(",(0,o.jsx)(n.a,{href:"https://docs.buildbuddy.io/docs/workflows-setup/",children:"https://docs.buildbuddy.io/docs/workflows-setup/"}),")","\nor ",(0,o.jsx)(n.a,{href:"https://docs.buildbuddy.io/docs/remote-bazel/",children:"Remote Bazel"})," by checking out the\ncorresponding docs."]}),"\n",(0,o.jsx)(n.p,{children:"If you've already linked your GitHub account to BuildBuddy, it'll only take\nabout 30 seconds to enable remote runners for your repo \u2014 just select a repo\nto link, and we'll take care of the rest!"})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>i});var r=s(96540);const o={},a=r.createContext(o);function t(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);