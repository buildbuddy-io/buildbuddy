"use strict";(self.webpackChunkbuildbuddy_docs_website=self.webpackChunkbuildbuddy_docs_website||[]).push([[1102],{52279:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"remote-runner-introduction","title":"Introduction to Remote Runners","description":"A BuildBuddy remote runner is an execution environment that runs on a BuildBuddy executor.","source":"@site/../docs/remote-runner-introduction.md","sourceDirName":".","slug":"/remote-runner-introduction","permalink":"/docs/remote-runner-introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/buildbuddy-io/buildbuddy/edit/master/docs/../docs/remote-runner-introduction.md","tags":[],"version":"current","lastUpdatedBy":"dependabot[bot]","lastUpdatedAt":1744142773000,"frontMatter":{"id":"remote-runner-introduction","title":"Introduction to Remote Runners","sidebar_label":"Remote Runner Introduction"},"sidebar":"someSidebar","previous":{"title":"RBE Executor Pools","permalink":"/docs/rbe-pools"},"next":{"title":"Remote Runner Features","permalink":"/docs/remote-runner-features"}}');var s=t(74848),o=t(28453);const i={id:"remote-runner-introduction",title:"Introduction to Remote Runners",sidebar_label:"Remote Runner Introduction"},a=void 0,l={},c=[{value:"Differences between Workflows and Remote Bazel",id:"differences-between-workflows-and-remote-bazel",level:2},{value:"Workflows",id:"workflows",level:4},{value:"Remote Bazel",id:"remote-bazel",level:4},{value:"Benefits of remote runners",id:"benefits-of-remote-runners",level:2},{value:"Colocation with BuildBuddy servers",id:"colocation-with-buildbuddy-servers",level:3},{value:"Hosted, warm, Bazel instances",id:"hosted-warm-bazel-instances",level:3},{value:"Bazel instance matching",id:"bazel-instance-matching",level:2},{value:"Firecracker VMs (Linux only)",id:"firecracker-vms-linux-only",level:3},{value:"Runner recycling (macOS only)",id:"runner-recycling-macos-only",level:3},{value:"Optimal usage of remote runners",id:"optimal-usage-of-remote-runners",level:2},{value:"Getting started",id:"getting-started",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"A BuildBuddy remote runner is an execution environment that runs on a BuildBuddy executor.\nOur remote runners are optimized to run Bazel commands, and allow users to maintain\na warm bazel instance in a secure execution environment managed by BuildBuddy.\nFor example, this might look like a Firecracker microVM or an OCI container where\nyou can run Bazel commands."}),"\n",(0,s.jsx)(n.p,{children:"BuildBuddy remote runners have the following unique advantages:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Colocation with BuildBuddy servers, ensuring a ",(0,s.jsx)(n.strong,{children:"fast network\nconnection"})," between Bazel and BuildBuddy's cache & RBE servers."]}),"\n",(0,s.jsxs)(n.li,{children:["Running workloads in ",(0,s.jsx)(n.strong,{children:"persistent execution environments"})," using microVM\nsnapshotting (on Linux) and persistent runners (on macOS). This allows reusing\nBazel's in-memory analysis cache and local disk cache, achieving higher performance\ncompared to remote caching alone."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"There are two ways to use remote runners:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"BuildBuddy Workflows:"})," Our continuous integration (CI) solution that runs Bazel builds and tests in response to git events (pull requests or pushes)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remote Bazel:"})," a CLI tool that works exactly like the Bazel command, but runs Bazel on a remote workspace and streams the output back to the local machine."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"https://www.buildbuddy.io/blog/meet-buildbuddy-workflows",children:"our blog post"}),"\nfor more details on the motivation behind remote runners as well as some\nreal-world results."]}),"\n",(0,s.jsx)(n.p,{children:"We currently support two products built on top of remote runners: Workflows and\nRemote Bazel."}),"\n",(0,s.jsx)(n.h2,{id:"differences-between-workflows-and-remote-bazel",children:"Differences between Workflows and Remote Bazel"}),"\n",(0,s.jsx)(n.p,{children:"In many ways, Remote Bazel and Workflows are the same product and share much of\nthe same backend code. Both are mechanisms to run code on remote runners. The\nprimary difference is the entrypoint."}),"\n",(0,s.jsx)(n.h4,{id:"workflows",children:"Workflows"}),"\n",(0,s.jsx)(n.p,{children:"Workflows are configured with a config YAML that is checked in to GitHub.\nRemote runs can be automatically triggered by GitHub events, like push and\npull events. Workflows are commonly used as a Continuous Integration (CI) solution."}),"\n",(0,s.jsx)(n.p,{children:"Workflows are a good fit if you:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Have a static list of commands to run"}),"\n",(0,s.jsx)(n.li,{children:"Want your commands checked in to your codebase for review"}),"\n",(0,s.jsx)(n.li,{children:"Are exclusively using BuildBuddy to run CI and do not have another CI provider\nthat can initiate commands"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"remote-bazel",children:"Remote Bazel"}),"\n",(0,s.jsx)(n.p,{children:"Remote Bazel can be configured by CURL request or by using the BuildBuddy CLI.\nRemote Bazel can be used as a Continuous Integration (CI) solution, or by developers\nin their daily workflows for use cases that are more dynamic than CI."}),"\n",(0,s.jsx)(n.p,{children:"Remote Bazel is a good fit if you:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Have a dynamic or frequently changing list of commands to run, that you do not\nwant to check into your codebase"}),"\n",(0,s.jsx)(n.li,{children:"You are continuing to use a legacy CI platform and want to integrate BuildBuddy\ninto it"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"benefits-of-remote-runners",children:"Benefits of remote runners"}),"\n",(0,s.jsx)(n.h3,{id:"colocation-with-buildbuddy-servers",children:"Colocation with BuildBuddy servers"}),"\n",(0,s.jsx)(n.p,{children:"Network latency is often the biggest bottleneck in many Bazel Remote Build\nExecution and Remote Caching setups. This is because Bazel's remote APIs\nrequire several chained RPCs due to dependencies between actions."}),"\n",(0,s.jsx)(n.p,{children:"To address this bottleneck, BuildBuddy remote runners are executed in the same\ndatacenters where BuildBuddy RBE and Cache nodes are deployed. This\nresults in sub-millisecond round trip times to BuildBuddy's servers,\nminimizing the overhead incurred by Bazel's remote APIs."}),"\n",(0,s.jsx)(n.h3,{id:"hosted-warm-bazel-instances",children:"Hosted, warm, Bazel instances"}),"\n",(0,s.jsx)(n.p,{children:"Running Bazel on most CI solutions is typically expensive and slow.\nThere are several sources of overhead:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When using Bazelisk, Bazel itself is re-downloaded and extracted on each\nCI run."}),"\n",(0,s.jsx)(n.li,{children:"The Bazel server starts from a cold JVM, meaning that it will be running\nunoptimized code until the JIT compiler kicks in."}),"\n",(0,s.jsx)(n.li,{children:"Bazel's analysis cache starts empty, which often means the entire\nworkspace has to be re-scanned on each CI run."}),"\n",(0,s.jsx)(n.li,{children:"Any remote repositories referenced by the Bazel workspace all have to be\nre-fetched on each run."}),"\n",(0,s.jsx)(n.li,{children:"Bazel's on-disk cache starts completely empty, causing action\nre-execution or excess remote cache usage."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A common solution is to use something like\n",(0,s.jsx)(n.a,{href:"https://github.com/actions/cache",children:"actions/cache"})," to store Bazel's cache\nfor reuse between runs, but this solution is extremely data-intensive, as\nBazel's cache can be several GB in size and consist of many individual\nfiles which are expensive to unpack from an archive. It also does not\nsolve the problems associated with the Bazel server having starting from\nscratch."]}),"\n",(0,s.jsxs)(n.p,{children:["By contrast, BuildBuddy uses a Bazel workspace reuse approach, similar to\nhow ",(0,s.jsx)(n.a,{href:"https://dl.acm.org/doi/pdf/10.1145/3395363.3397371",children:"Google's Build Dequeuing Service"})," performs\nworkspace selection:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"A well-chosen workspace can increase the build speed by an\norder of magnitude by reusing the various cached results from the\nprevious execution. [...] We have observed that builds that execute the same targets as a previous\nbuild are effectively no-ops using this technique"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"bazel-instance-matching",children:"Bazel instance matching"}),"\n",(0,s.jsxs)(n.p,{children:["To match remote runs to warm Bazel instances, BuildBuddy uses VM\nsnapshotting powered by\n",(0,s.jsx)(n.a,{href:"https://github.com/firecracker-microvm/firecracker",children:"Firecracker"})," on\nLinux, and a simpler runner-recycling based approach on macOS."]}),"\n",(0,s.jsx)(n.h3,{id:"firecracker-vms-linux-only",children:"Firecracker VMs (Linux only)"}),"\n",(0,s.jsx)(n.p,{children:"On Linux, remote runs are executed inside Firecracker VMs, which\nhave a low startup time (hundreds of milliseconds). VM snapshots include\nthe full disk and memory contents of the machine, meaning that the Bazel\nserver is effectively kept warm between runs."}),"\n",(0,s.jsx)(n.p,{children:"Remote runners use a sophisticated snapshotting mechanism that minimizes the\nwork that Bazel has to do on each CI run."}),"\n",(0,s.jsx)(n.p,{children:"First, VM snapshots are stored both locally on the machine that ran the\nremote run, as well as remotely in BuildBuddy's cache. This way, if the\noriginal machine that ran the remote run is fully occupied with other\nworkloads, subsequent runs can be executed on another machine,\nbut still be able to resume from a warm VM snapshot. BuildBuddy stores VM\nsnapshots in granular chunks that are downloaded lazily, so that unneeded\ndisk and memory chunks are not re-downloaded."}),"\n",(0,s.jsx)(n.p,{children:"Second, snapshots are stored using a branching model that closely mirrors\nthe branching structure of the git repository itself, allowing remote runs\nto be matched optimally to VM snapshots."}),"\n",(0,s.jsx)(n.p,{children:"After a remote run executes on a particular git branch, BuildBuddy snapshots the\nVM and saves it under a cache key which includes the git branch."}),"\n",(0,s.jsx)(n.p,{children:"When starting a remote run on a particular git branch, BuildBuddy\nattempts to locate an optimal snapshot to run it. It considers\nthe following snapshot keys in order:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The latest snapshot matching the git branch associated with the\nrun."}),"\n",(0,s.jsx)(n.li,{children:"The latest snapshot matching the base branch of the PR associated with\nthe run."}),"\n",(0,s.jsx)(n.li,{children:"The latest snapshot matching the default branch of the repo associated\nwith the run."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, consider a remote run that runs on pull requests\n(PRs). Given a PR that is attempting to merge the branch ",(0,s.jsx)(n.code,{children:"users-ui"})," into a\nPR base branch ",(0,s.jsx)(n.code,{children:"users-api"}),", BuildBuddy will first try to resume the latest\nsnapshot associated with the ",(0,s.jsx)(n.code,{children:"users-ui"})," branch. If that doesn't exist,\nwe'll try to resume from the snapshot associated with the ",(0,s.jsx)(n.code,{children:"users-api"}),"\nbranch. If that doesn't exist, we'll look for a snapshot for the ",(0,s.jsx)(n.code,{children:"main"}),"\nbranch (the repo's default branch). If all of that fails, only then do we\nboot a new VM from scratch. When the remote run finishes and we save a\nsnapshot, we only overwrite the snapshot for the ",(0,s.jsx)(n.code,{children:"users-ui"})," branch,\nmeaning that the ",(0,s.jsx)(n.code,{children:"users-api"})," and ",(0,s.jsx)(n.code,{children:"main"})," branch snapshots will not be\naffected."]}),"\n",(0,s.jsxs)(n.p,{children:["For more technical details on our VM implementation, see our BazelCon\ntalk ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=YycEXBlv7ZA",children:"Reusing Bazel's Analysis Cache by Cloning Micro-VMs"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"runner-recycling-macos-only",children:"Runner recycling (macOS only)"}),"\n",(0,s.jsx)(n.p,{children:"On macOS, remote runs are matched to workspaces using a simpler\nrunner-recycling based approach. Remote runs are associated with Git\nrepositories, and matched to any runner associated with the repository.\nEach runner keeps a separate Bazel workspace directory and on-disk cache,\nas well as its own Bazel server instance, which is kept alive between\nruns. Runners are evicted from the machine only if the number of runners\nexceeds a configured limit or if the disk resource usage exceeds a\nconfigured amount."}),"\n",(0,s.jsxs)(n.p,{children:["macOS remote runners are only available for self-hosted Macs. See our\n",(0,s.jsx)(n.a,{href:"workflows-config#mac-configuration",children:"configuration docs"})," for more details,\nor ",(0,s.jsx)(n.a,{href:"https://www.buildbuddy.io/contact",children:"contact us"})," for more info about\nBuildBuddy-managed Macs."]}),"\n",(0,s.jsx)(n.h2,{id:"optimal-usage-of-remote-runners",children:"Optimal usage of remote runners"}),"\n",(0,s.jsx)(n.p,{children:"While our remote runners support running arbitrary bash code, they were specifically\ndesigned and optimized to run the Bazel client server and power Bazel commands with\nremote execution (RBE)."}),"\n",(0,s.jsx)(n.p,{children:"Because we snapshot the entire memory and disk of each runner, the product is slower\nwhen we must serialize and deserialize larger runners. Thus we have a 100GB limit\non disks for remote runners."}),"\n",(0,s.jsx)(n.p,{children:"It's more effective when a smaller remote runner is used to orchestrate farming out most computation to\ntraditional Bazel remote executors."}),"\n",(0,s.jsx)(n.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,s.jsxs)(n.p,{children:["You can get started with [BuildBuddy Workflows(",(0,s.jsx)(n.a,{href:"https://docs.buildbuddy.io/docs/workflows-setup/",children:"https://docs.buildbuddy.io/docs/workflows-setup/"}),")","\nor ",(0,s.jsx)(n.a,{href:"https://docs.buildbuddy.io/docs/remote-bazel/",children:"Remote Bazel"})," by checking out the\ncorresponding docs."]}),"\n",(0,s.jsx)(n.p,{children:"If you've already linked your GitHub account to BuildBuddy, it'll only take\nabout 30 seconds to enable remote runners for your repo \u2014 just select a repo\nto link, and we'll take care of the rest!"})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);