"use strict";(self.webpackChunkbuildbuddy_docs_website=self.webpackChunkbuildbuddy_docs_website||[]).push([[3018],{97423:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=n(74848),a=n(28453);const i={slug:"bazel-remote-cache-debugging",title:"Bazel Remote Cache Debugging",description:"All about the new cache requests card and how to use it.",author:"Brandon Duffany",author_title:"Engineer @ BuildBuddy",date:"2022-06-07:12:00:00",author_url:"https://github.com/bduffany",author_image_url:"https://avatars.githubusercontent.com/u/2414826?v=4",image:"/img/blog/remote-cache-debugging.png",tags:["product","engineering"]},o=void 0,r={permalink:"/blog/bazel-remote-cache-debugging",editUrl:"https://github.com/buildbuddy-io/buildbuddy/edit/master/website/blog/bazel-remote-cache-debugging.md",source:"@site/blog/bazel-remote-cache-debugging.md",title:"Bazel Remote Cache Debugging",description:"All about the new cache requests card and how to use it.",date:"2022-06-07T12:00:00.000Z",tags:[{inline:!0,label:"product",permalink:"/blog/tags/product"},{inline:!0,label:"engineering",permalink:"/blog/tags/engineering"}],readingTime:4.705,hasTruncateMarker:!0,authors:[{name:"Brandon Duffany",title:"Engineer @ BuildBuddy",url:"https://github.com/bduffany",imageURL:"https://avatars.githubusercontent.com/u/2414826?v=4",key:null,page:null}],frontMatter:{slug:"bazel-remote-cache-debugging",title:"Bazel Remote Cache Debugging",description:"All about the new cache requests card and how to use it.",author:"Brandon Duffany",author_title:"Engineer @ BuildBuddy",date:"2022-06-07:12:00:00",author_url:"https://github.com/bduffany",author_image_url:"https://avatars.githubusercontent.com/u/2414826?v=4",image:"/img/blog/remote-cache-debugging.png",tags:["product","engineering"]},unlisted:!1,prevItem:{title:"Welcoming Maggie Lou",permalink:"/blog/welcoming-maggie-lou"},nextItem:{title:"Distributed Scheduling for Faster Builds",permalink:"/blog/distributed-scheduling-for-faster-builds"}},d={authorsImageUrls:[void 0]},l=[{value:"New insights",id:"new-insights",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"What&#39;s next",id:"whats-next",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",img:"img",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Using a remote cache is a great way to speed up your Bazel builds! But by\ndefault, Bazel uploads almost everything to the remote cache."}),"\n",(0,s.jsx)(t.p,{children:"If your network is slow and your build artifacts are very large (like a\ndocker image) this can lead to poor performance."}),"\n",(0,s.jsx)(t.p,{children:"To address this, and make it easier to fix, we built the new cache\nrequests card."}),"\n",(0,s.jsx)(t.p,{children:"In this post we'll explore what insights this card can give you into your\nbuilds, as well as some fun details about how the card works under the\nhood."}),"\n",(0,s.jsx)(t.h2,{id:"new-insights",children:"New insights"}),"\n",(0,s.jsx)(t.p,{children:"The cache requests card lets you answer some interesting questions about\nyour build which were not easily answerable before. Here are a few:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"My build seems to have uploaded a lot of data \u2014 which targets\nuploaded the largest artifacts?"})})}),"\n",(0,s.jsxs)(t.p,{children:['To answer this question, select "Sort by ',(0,s.jsx)(t.strong,{children:"Size"}),'" and "Show ',(0,s.jsx)(t.strong,{children:"All"}),'".\nThen, select "Group by ',(0,s.jsx)(t.strong,{children:"None"}),'". This will show the largest artifacts\nfirst, with target names displayed in the leftmost column.']}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(30232).A+"",width:"964",height:"426"})}),"\n",(0,s.jsxs)(t.p,{children:["We can see in this screenshot that the largest cache transfer was a\ndownload of an artifact from the external repository\n",(0,s.jsx)(t.code,{children:"com_github_tuist_xcodeproj"}),". To see the full target and action name,\nhover over the row."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"I see some file references in the build event stream which aren't\nassociated with an action. What are these files?"})})}),"\n",(0,s.jsxs)(t.p,{children:['To answer this question, select "Show ',(0,s.jsx)(t.strong,{children:"All"}),'" and search for\n',(0,s.jsx)(t.strong,{children:"bes-upload"}),". You'll see all the files which were uploaded by Bazel\nand not associated with an action, including the timing profile."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(4783).A+"",width:"970",height:"384"})}),"\n",(0,s.jsx)(t.p,{children:"The build in this screenshot shows that a large artifact (285.9 MB) was\nuploaded at the very end of the build, so it most likely was blocking the\nbuild's completion. We can see the full artifact path by hovering over the\nrow."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:(0,s.jsx)(t.strong,{children:"I expected my build to be fully-cached, but it was not. Was there a\nsingle action whose inputs or environment variables changed unexpectedly,\nthus triggering all its dependent targets to be rebuilt?"})})}),"\n",(0,s.jsxs)(t.p,{children:["To answer this question, make sure you are sorted by ",(0,s.jsx)(t.strong,{children:"start time"})," in\nascending order, and take a look at the actions with the earliest\ntimestamps. The earliest action is most likely the root cause of the\nchange from the previous build."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(72805).A+"",width:"964",height:"497"})}),"\n",(0,s.jsxs)(t.p,{children:["Before the build in this screenshot, a file in the\n",(0,s.jsx)(t.code,{children:"priority_task_scheduler"})," target was edited, which we can see triggered a\ncascade of action executions that transitively depended on\n",(0,s.jsx)(t.code,{children:"priority_task_scheduler"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,s.jsx)(t.p,{children:"Implementing the cache requests card required solving a few interesting\nproblems."}),"\n",(0,s.jsx)(t.p,{children:"The total size of the request metadata stored for each build is not\nextremely large \u2014 just tens of megabytes for builds with hundreds of\nthousands of cache requests \u2014 but we serve a high volume of\nrequests, and we don't want to negatively impact cache performance just to\nstore this metadata for each request."}),"\n",(0,s.jsx)(t.p,{children:"The simplest solution to implement would be to do a blocking write to a\nMySQL table for each cache request. This would also be pretty convenient\nfor querying the data however we like. However, this would place far too\nmuch load on the database and add way too much latency to each cache\nrequest."}),"\n",(0,s.jsx)(t.p,{children:"So, instead of using MySQL, we used Redis as an intermediate storage\nmedium while the invocation is in progress. Redis can handle a much higher\nvolume of writes than MySQL because it only stores values in memory and it\nhas a much simpler key-value storage model."}),"\n",(0,s.jsxs)(t.p,{children:["We can't just store this data in Redis and call it a day, though. Firstly,\nRedis does not give us long-term persistence, and it would be nice to be\nable to keep this data around even for older invocations. To get long-term\npersistence, we read all of the data from Redis and then serialize it into\na ",(0,s.jsx)(t.a,{href:"https://developers.google.com/protocol-buffers",children:"proto"}),'. We store this\nproto into a "blobstore," which is just a generic storage interface backed\nby a local disk, Google Cloud Storage, Amazon S3, etc.']}),"\n",(0,s.jsxs)(t.p,{children:["Secondly, even with the amazing performance of Redis, we can't just issue\na single write request for every cache request. Doing a separate Redis\nwrite for every request places a large amount of CPU load on Redis, since\nit needs to do a ",(0,s.jsx)(t.code,{children:"read()"})," and ",(0,s.jsx)(t.code,{children:"write()"})," system call for each write.\n(We learned this the hard way.)"]}),"\n",(0,s.jsxs)(t.p,{children:["To address this, we used Redis\n",(0,s.jsx)(t.a,{href:"https://redis.io/docs/manual/pipelining/",children:(0,s.jsx)(t.strong,{children:"pipelining"})}),". Instead of\nissuing Redis commands directly, we add each command to a pipeline, and\nhave a separate background job that periodically flushes the pipeline.\nAdding the command to the pipeline is just a matter of appending to an\nin-memory buffer, which takes just nanoseconds, so it doesn't impact cache\nperformance to a significant degree."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(89642).A+"",width:"787",height:"321"})}),"\n",(0,s.jsx)(t.p,{children:"Once an invocation is complete, we kick off a job to read all of the\nrequests from Redis and then store it as a single blob in blobstore."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(38625).A+"",width:"586",height:"353"})}),"\n",(0,s.jsx)(t.p,{children:"To read back this data for the UI, all we have to do is load this whole\nblob into memory and then apply any client-side sorting and filtering.\nThese blobs are small enough that we easily load the full blob into memory\non the server \u2014 the blob is too big to be loaded in a browser,\nthough, so we do use a relatively small page size."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(65912).A+"",width:"734",height:"261"})}),"\n",(0,s.jsx)(t.h2,{id:"whats-next",children:"What's next"}),"\n",(0,s.jsxs)(t.p,{children:["We hope that you find the new cache requests card useful and that you\nenjoyed reading about how it works! We would love to hear your feedback,\nwhich will help inform how we design the next iteration of our cache\ndebugging tools to help make your builds even faster and more scalable.\nJoin our ",(0,s.jsx)(t.a,{href:"https://community.buildbuddy.io",children:"Slack channel"})," or email us at\n",(0,s.jsx)(t.a,{href:"mailto:hello@buildbuddy.io",children:"hello@buildbuddy.io"})," with any questions, comments, or thoughts."]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},4783:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cache-requests-card-bes-upload-7e293efaf52bed7ebcb56232c8d5b0ba.png"},72805:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cache-requests-card-incremental-rebuild-c02480aa14d8761c7a51df2ca2c2257a.png"},30232:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cache-requests-card-135fa673793b16090aafac8f4ded32cc.png"},89642:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cache-requests-design-1-bb9607923185df1a8ec1ac72b31f8c1a.png"},38625:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cache-requests-design-2-0ffff643976481b7c66e88f3caa70c4f.png"},65912:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cache-requests-design-3-b2207697c8c431ab47b9653255dd12ed.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);