syntax = "proto3";

import "proto/context.proto";
import "proto/firecracker.proto";
import "proto/git.proto";
import "proto/remote_execution.proto";

package runner;

message RunRequest {
  // The request context.
  context.RequestContext request_context = 1;

  // The git repository to checkout. Required.
  git.GitRepo git_repo = 2;

  // The state of the repository.
  // A minimum of commit_sha or branch must be specified.
  git.RepoState repo_state = 3;

  // The bazel command to run. Required.
  // Example: "build :server"
  // Example: "test //..."
  string bazel_command = 4;

  // The remote instance name. Everything happens within this namespace, so
  // changing this key will mean hitting a different cache and remote executor.
  // Optional.
  string instance_name = 5;

  // Key used to indicate preference to which Bazel instance the request should
  // be routed to.
  string session_affinity_key = 6;

  // OS on which to run. Defaults to "linux".
  string os = 7;

  // Arch on which to run. Defaults to "amd64".
  string arch = 8;

  // If true, start the runner but do not wait for the action to be scheduled.
  bool async = 9;

  // Container image to run on. Defaults to the Ubuntu 20.04 Workflows image.
  // A `docker://` prefix is required.
  // Ex. `docker://gcr.io/flame-public/rbe-ubuntu20-04`
  string container_image = 10;

  // Environment variables to set in the runner env.
  map<string, string> env = 11;

  // Max time before run should be canceled automatically.
  string timeout = 12;

  // Exec properties to apply to the run request.
  repeated build.bazel.remote.execution.v2.Platform.Property exec_properties =
      13;

  // If true, binaries generated by a `bazel run` command will be executed
  // remotely. If false or unset, run metadata (runtime flags, files, etc) will
  // be collected so the binary can be run elsewhere.
  bool run_remotely = 14;

  // Flags to pass directly to the runner.
  repeated string runner_flags = 15;
}

message RunResponse {
  // The response context.
  context.ResponseContext response_context = 1;

  // The invocation ID of the run.
  string invocation_id = 2;
}

// RunnerPoolState is used to serialize the state of the runner pool to disk so
// that we can restore the runner pool after an executor restart.
message RunnerPoolState {
  // The list of pooled runners that were present when the executor shut down.
  repeated RunnerState runner_states = 1;
}

// Runner key represents a fixed set of runner properties which are assigned
// when a runner is created. When assigning tasks to pooled runners, the task's
// computed runner key must match the runner's key.
message RunnerKey {
  // BuildBuddy group ID.
  string group_id = 1;

  // Remote instance name.
  string instance_name = 2;

  // Platform associated with the runner.
  build.bazel.remote.execution.v2.Platform platform = 3;

  // Persistent worker key, which will either match the "persistentWorkerKey"
  // platform property, or if unset, will default to the persistent worker's
  // command-line configuration (non-flagfile arguments).
  string persistent_worker_key = 4;
}

message RunnerState {
  // Runner key.
  RunnerKey runner_key = 1;

  // State specific to the isolation type in use.
  ContainerState container_state = 2;

  // Short debug ID used to identify the runner.
  string debug_id = 3;

  // Counter that is incremented each time the runner is assigned a new task.
  int64 assigned_task_count = 4;
}

// The container-specific runner state.
message ContainerState {
  // Isolation type determines which container state field should be set.
  // Example: "firecracker"
  string isolation_type = 1;

  // Firecracker microVM state.
  // Set when isolation_type == "firecracker".
  FirecrackerState firecracker_state = 2;
}

message FirecrackerState {
  // The snapshot key pointing to the snapshot manifest file in the executor's
  // local cache.
  firecracker.SnapshotKey snapshot_key = 1;

  // The static VM configuration.
  firecracker.VMConfiguration vm_configuration = 2;
}
